



Detecting Unwanted Location Trackers                        C. Fossaceca
Internet-Draft                                                 Microsoft
Intended status: Informational                               E. Rescorla
Expires: 9 January 2025                          Windy Hill Systems, LLC
                                                             8 July 2024


                         Finding Tracking Tags
                  draft-fossaceca-dult-finding-latest

Abstract

   Lightweight location tracking tags are in wide use to allow users to
   locate items.  These tags function as a component of a crowdsourced
   tracking network in which devices belonging to other network users
   (e.g., phones) report which tags they see and their location, thus
   allowing the owner of the tag to determine where their tag was most
   recently seen.  This document defines the protocol by which devices
   report tags they have seen and by which owners look up their
   location.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://ekr.github.io/draft-fossaceca-dult-finding/draft-fossaceca-
   dult-finding.html.  Status information for this document may be found
   at https://datatracker.ietf.org/doc/draft-fossaceca-dult-finding/.

   Discussion of this document takes place on the Detecting Unwanted
   Location Trackers Working Group mailing list (mailto:unwanted-
   trackers@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/unwanted-trackers/.
   Subscribe at https://www.ietf.org/mailman/listinfo/unwanted-
   trackers/.

   Source for this draft and an issue tracker can be found at
   https://github.com/ekr/draft-fossaceca-dult-finding.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 9 January 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Motivations
     2.1.  Stalking Prevention
     2.2.  Existing Protocols
   3.  Conventions and Definitions
   4.  Protocol Overview
     4.1.  High Level Protocol
     4.2.  General Protocol Infrastructure Properties
     4.3.  Partial Blind Signature Scheme
     4.4.  Initial Pairing / Accessory Setup
       4.4.1.  Authenticity Verification
       4.4.2.  Key Generation and Signing with Partial Blind
               Signatures
     4.5.  Accessory Behavior
       4.5.1.  Accessory in Nearby Owner Mode
       4.5.2.  Accessory in Separated (Lost) Mode
     4.6.  Finder Device creates a Location Report
     4.7.  Owner Device queries the Crowdsourced Network
     4.8.  Reporting Device Leakage
     4.9.  Non-compliant Accessories
   5.  Security Considerations
   6.  Privacy Considerations
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Lightweight location tracking tags are a mechanism by which users can
   track their personal items.  These tags function as a component of a
   crowdsourced tracking network in which devices belonging to other
   network users (e.g., phones) report on the location of tags they have
   seen.  At a high level, this works as follows:

   *  Tags ("Accessories") broadcast an advertisement payload containing
      accessory-specific information.  The payload also indicates
      whether the accessory is separated from its owner and thus
      potentially lost.

   *  Devices belonging to other users ("Non-Owner Devices" or "Finder
      Devices") observe those payloads and if the payload is in a
      separated mode, reports its location to some central service
      ("crowdsourced network").

   *  The owner ("Owner Device") queries the central service
      ("crowdsourced network") for the location of their accessory.

   A naive implementation of this design exposes users to considerable
   privacy risk.  In particular:

   *  If accessories simply have a fixed identifier that is reported
      back to the tracking network, then the central server is able to
      track any accessory without the user's assistance, which is
      clearly undesirable.

   *  Any attacker who can guess a tag ID can query the central server
      for its location.

   *  An attacker can surreptitiously plant an accessory on a target and
      thus track them by tracking their "own" accessory.

   Section 5 provides more detailed definition of the desired security
   privacy properties, but briefly, we would like to have a system in
   which:

   *  Nobody other than the owner of an accessory would be able to learn
      anything about the location of a given accessory.

   *  It is possible to detect when an accessory is being used to track
      you.

   *  It is not possible for accessories that do not adhere to the
      protocol to use the crowdsourced network protocol.

   *  It is not possible for unverified accessories to use the
      crowdsourced network protocol.

   This document defines a cryptographic reporting and finding protocol
   which is intended to minimize these privacy risks.  It is intended to
   work in concert with the requirements defined in
   [I-D.detecting-unwanted-location-trackers], which facilitate
   detection of unwanted tracking tags.  This protocol design is based
   on existing academic research surrounding the security and privacy of
   bluetooth location tracking accessories on the market today, as
   described in [BlindMy] and [GMCKV21].

2.  Motivations

2.1.  Stalking Prevention

   This work has been inspired by the negative security and privacy
   implications that were introduced by lightweight location tracking
   tags, and defined in part by
   [I-D.detecting-unwanted-location-trackers].  The full threat model is
   described in detail in [DultDoc4], however, a significant element of
   the threat model lies in part with the security of the Crowdsourced
   Network, which will be discussed in detail here.

   The Crowdsourced Network has unwittingly provided stalkers with a
   means to anonymously upload and download location reports from BLE
   trackers.  Thus, this document outlines the requirements and
   responsibilities of the Crowdsourced Network to verify the
   authenticity of the participants, while also preserving user privacy.

   *  First, the Crowdsourced Network has a responsibility to ensure
      that only authentic Finding Devices are sending reports to the
      Crowdsourced Network, and this should occur via an authenticated
      and encrypted channel.  This will help prevent malicious actors
      from interfering with location reporting services.

   *  Second, the Crowdsourced Network has a responsibility to ensure
      that only authorized Owner Devices are able to download location
      reports, and this should occur via an authenticated and encrypted
      channel.  This will prevent malicious actors from unauthorized
      access of location data.

   *  Third, the Crowdsourced Network must follow basic security
      principles, such as

      -  Storing location reports in an encrypted manner

      -  Limiting location report data storage to 7 days or less

      _(The benefits of this requirement are self explanatory.)_

   *  Fourth, the Crowdsourced Network must validate that the accessory
      registered to an owner is valid.  This wil prevent malicious
      actors from leveraging counterfeit accessories.

   *  Fifth, users should should be able to opt-out of their devices
      participating in the Crowdsourced Network.

2.2.  Existing Protocols

   There are a variety of different products on the market today that
   leverage a Crowdsourced Network for location tracking.  Currently,
   each manufacturer has designed its own implementation and product.

   These include:

   *  Apple and the AirTag, as described in [WhoTracks] and [Heinrich]

   *  Samsung and the SmartTag, as described in [Samsung]

   *  Tile, CUBE, Chipolo, Pebblebee and TrackR as described in
      [GMCKV21]

3.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Section 1.2 of [I-D.detecting-unwanted-location-trackers] provides
   definitions of the various system components.

   Accessory (ACC): This is the device which will be tracked.  It is
   assumed to lack direct internet access and GPS, but will possess
   Bluetooth Low Energy capabilities, which it uses to send
   advertisement messages.  The accessory protocol is defined in
   [DultDoc3].

   Advertisement: This is the message that is sent over the BLE Protocol
   from the Accessory

   Crowdsourced Network (CN): This is the network that provides the
   location reporting upload and download services for Owner Devices and
   Dinder Devices.

   Finder Device (FD): This is a device that is a non-owner device that
   contributes information about an accessory to the crowdsourced
   network.

   Owner Device (OD): This is the device which owns the accessory, and
   to which it is paired.  There can be multiple owner devices, however,
   the security of that implementation is outside of the scope of this
   document.

4.  Protocol Overview

4.1.  High Level Protocol

   Figure 1 provides an overall view of the protocol.

   In this protocol, the Accessory communicates to Finder Devices or
   FDs(such as phones) solely via Bluetooth, and the FDs communicate to
   a centralized service on the Crowdsourced Network CN.  Only during
   the setup phase is the Owner Device OD able to act as a relay between
   the Accessory ACC and the Crowdsourced Network CN.  In this
   implementation, the CN is able to act as a verifier and signer by
   leveraging Blind Signatures, which allows the OD to obtain a
   signature from the signer CN without revealing the input to the CN.

                              ╭――――――――――――――――――╮
                              │        o         │
                              │ ╭──────────────╮ │
                              │ │              │ │
                              │ │              │ │                        .-~~~-.
                              │ │              │ │                .- ~ ~-(       )_ _
    o  o                      │ │              │ │               /                     ~ -.
 o        o                   │ │              │ │              |                           \
o          o     ------->     │ │              │ │   ------->    \                         .'
o          o                  │ │              │ │                 ~- . _____________ . -~
 o        o                   │ │              │ │
    o  o                      │ │              │ │
                              │ │              │ │
                              │ ╰──────────────╯ │
                              │       (_)        │
                              ╰――――――――――――――――――╯



  Accessory         BLE           Finder Device      Location            CN Server
               Advertisement                          Upload

                     Figure 1: Protocol Overview

   In this implementation, there are 4 stages that will be outlined,
   taking into account elements from both [BlindMy] and [GMCKV21].
   These stages are as follows:

   1) *Initial Pairing / Accessory Setup*

   In this phase, the Accessory ACC is paired with the Owner Device OD,
   and verified as authentic with the Crowdsourced Network CN

   2) *Accessory in Nearby Owner Mode*

   In this phase, the Accessory ACC is within Bluetooth range of the
   Owner Device OD.  In this phase, Finder Devices FDs SHALL NOT
   generate location reports to send to the Crownsourced Network CN.
   The Accessory SHALL behave as defined in [DultDoc3].

   3) *Accessory in Separated (Lost) Mode*

   In this phase, the Accessory ACC is not within Bluetooth raange fo
   the Owner Device OD, therefore, the accessory must generate "lost"
   messages to be received by Finder Devices FD, as described in
   [DultDoc3].

   4) *Finder Device creates a location report*

   Finder Device FD receives a Bluetooth packet, and uploads a location
   report to the Crowdsourced Network CN if and only if it is confirmed
   to be a valid location report.

   *(Should this be confirmed by the FD, or the CN? or Both?)

   5) *Owner Device queries the Crowdsourced Network*

   Owner Device OD queries the Crowdsourced Network CN for the encrypted
   location report.

4.2.  General Protocol Infrastructure Properties

   Relying on [BlindMy], we define the following constraints:

   *  There exists an agreed upon elliptic curve group with a generator,
      a secure Message Authentication Algorithm, and a hashing function
      _H_.

   *  CN knows a key pair (K_S,P_S), where the public key P_S is known
      to all participants.

   *  CN has a private symmetric encryption key K_SERIAL.

   *  CN maintains a database of registered serial values D_SERIAL

   *  Each Accessory ACC_i contains a unique serial number and tag
      (Serial_i, T_i)

   *  All parties have a synchronized clock and the ability to represent
      the current day (or another arbitrary timestamp) as an integer

   *  A parameter _N_ is defined by the protocol that represents the
      number of encryption keys produced during the pairing algorithm.

4.3.  Partial Blind Signature Scheme

   In order to verify the parties involved in the protocol, we rely on a
   partial blind signature scheme as defined in [BlindMy] and [Okamoto]:

      +============================================================+
      |               Partial Blind Signature Scheme               |
      +============================================================+
      |    * There exists a probabilistic polynomial time (PPT)    |
      | algorithm called _KeyGen_ that takes a security parameter  |
      |  as input and outputs a key pair containing a secret key   |
      |                 and public key (s_k,p_k).                  |
      +------------------------------------------------------------+
      |    * There exists two interactive PPT algorithms called    |
      |    _Signer_ and _User_ that compute a signature σ of a     |
      |  message m and plaintext auxiliary information info.  The  |
      | _Signer_ begins with (s_k,p_k,info), and the _User_ starts |
      | with (p_k,info, m).  After interacting, the _User_ outputs |
      |    (m, σ ) if the protocol succeeds and ⊥ if it fails.     |
      +------------------------------------------------------------+
      |    * There exists a PPT algorithm called _Verify_ that     |
      |   receives (p_k,info, m,σ ) and outputs accept when the    |
      |        signature is valid, and reject if it is not.        |
      +------------------------------------------------------------+

                                 Table 1

4.4.  Initial Pairing / Accessory Setup

   During the pairing process, the Accessory ACC pairs with the Owner
   Device OD over Bluetooth.  In this process, the ACC and OD must
   generate cryptographically secure keys that will allow for the OD to
   decrypt the ACC location reports.

4.4.1.  Authenticity Verification

   Upon the initial pairing of the the ACC and OD, before the key
   generation process, the OD must facilitate communication with the CN
   to verify the authenticity of the ACC.  In [GMCKV21], it is
   recommended that the ACC has a private key material fused into the
   chip at manufacture time.

   In [BlindMy], the principal of _Serial Unforgeability_ is introduced,
   which recommends that the serial numbers are assigned as an
   unforgeable MAC that is computed with a secret key only known to the
   server.

   (1)OD extracts the values (Serial_i, T_i) from ACC, where

   T_i = MAC_KSERIAL(Serial_i)

   (2) OD transmits these values to CN.

   (3) CN independently verifies T_i

   (4) To prevent re-enrollment of a tag, CN also checks Serial_i ∉
   D_SERIAL

   (5) If (3) or (4) fails, CN aborts.  Otherwise, CN adds Serial_i to
   D_SERIAL

   (6) CN sends public parameters for generating _N_ partial blind
   signatures to OD.  These parameters are defined in the next section.

4.4.2.  Key Generation and Signing with Partial Blind Signatures

   In order for OD to have _N_ keys signed by partial blind signatures,
   the scheme described in [BlindMy] must be implemented.

   For convenience, it is summarized below:

   (1) CN generates the public parameters u, d, s, a, b where u, d, s
   represent the Signer State and a, b represents the Signature
   Parameters.

   They are generated by the following code given in [BlindMy]
   _pbs_dh.py_:

   def raw_signer_gen_params(hashfunc, privkey, info):
       u = randbelow(q)
       d = randbelow(q)
       s = randbelow(q)

       z = hashToPoint(info, hashfunc)
       a = pow(g, u, p)
       b = (pow(g,s,p) * pow(z,d,p)) % p

       return (u, d, s, a, b)

   (2) After receiving the public parameters required from CN, OD
   generates N elliptic-curve keypairs, as shown in the code from
   [BlindMy] _client.py_:

   def gen_keys(privateseed: str, numkeys: int) -> List[str]:
       print(f"Generating {numkeys} keys")
       pubkeys = []
       for i in tqdm(range(numkeys)):
           pkey = hashToInt(privateseed + str(i), P224, sha256)
           pubkey = pkey * P224.G
           pubkeyx = '{:056x}'.format(pubkey.x)
           pubkeys.append(pubkeyx)
       return pubkeys

   (3) OD generates signing requests for each public key in _N_,using
   params _a_ and _b_, the hashing function _H_, and the auxiliary info
   for each signing request set as the integer representation of the
   current day and the _N − 1_ following days.  These requests are then
   sent to CN.  Notice that OD performs blinding on each public key
   before making the request.

   This is shown in the code from [BlindMy] _pbs_dh.py_:

    #sigparams - SignatureParams object, comes from generate_params function above
    #msg - string or bytes object representing the message being signed
    #info - string representing the plaintext auxiliary information to go along with the blinded signature
    def generate_signature_request(self, sigparams, msg, info):
        t1, t2, t3, t4, e = raw_user_blind(self.hashfunc, self.pubkey, msg, info, sigparams.a, sigparams.b)
        return UserState(t1, t2, t3, t4), e

   (4) CN verifies the timestamp infomation and aborts if not in a valid
   range.

   (5) CN signs each each public key with a blind signature and sends
   the _N_ blind signatures to OD.

   (6) OD unblinds the signatures and stores _N_ pairs of the form
   (KeyPair, UnblindedSignature) and transfers the _N_ public keys to
   the accessory ACC, ordered by timestamp.

4.5.  Accessory Behavior

   As part of the setup phase (described in [DultDoc3]) the Accessory
   ACC and Owner Device OD are paired, establishing a shared key S_K
   which is known to both the accessory and the owning device.  The rest
   of the protocol proceeds as follows:

4.5.1.  Accessory in Nearby Owner Mode

   After pairing, when the Accessory ACC is in Bluetooth range of OD, it
   will follow the protocol as decribed in [DultDoc3].

4.5.2.  Accessory in Separated (Lost) Mode

   After pairing, when the Accessory ACC no longer in the Bluetooth
   range of OD, it will follow the protocol as decribed below:, which
   should correspond to the behavior outlined in [DultDoc3]:

   ACC periodically sends out an Advertisement which contains an
   ephemeral public key Y_i where i is the epoch the key is valid for.
   As defined by our protocol, this epoch is a 24 hour period.  Y_i and
   its corresponding private key X_i are generated in a deterministic
   fashion from S_K and the epoch i (conceptually as X_i = PRF(S_K, i)).

   The full payload format of the Advertisement is defined in
   [DultDoc3].

4.6.  Finder Device creates a Location Report

   The Finder Device FD receives the advertisement via Bluetooth.  FD
   should have a mechanism by which to authenticate that this is a valid
   public key with CN. *

   In order to report an accessory's location at time i, FD extracts the
   elliptic curve public key from the advertisement, and records it own
   location data, a timestamp, and a confidence value as described in
   [Heinrich].

   FD performs ECDH with the public key Y_i and derives a shared
   symmetric key with ECIES.

   It then encrypts the location data using the symmetric key, and
   creates a payload as described in [Heinrich] and [WhoTracks].  It
   transmits a payload to CN with the encrypted packet (
   E(Y_i,location), Y_i).

   FD uploads the encrypted payload, the public ephemeral key, a
   timestamp, and the hash of the public key to CN, who records it in a
   key-value store with the key as the hash of the ACC public key.

   * Some ideas include

   *  FD can request a signature itself of the key - but would it be the
      same?

   *  ACC can send the public key and the signature to FD so FD can
      verify the signature

   *  CN has the option of discarding the packet if the hash of the
      public key is unknown, since the server has already signed all of
      the keys in the past - but is it reasonable to save/store these?

4.7.  Owner Device queries the Crowdsourced Network

   Following the sequence described in [BlindMy], valid ODs can retrieve
   the location of a paired ACC.  In order to query the location of ACC,
   the OD can sends a request to the CN.  The CN must verify that each
   location requested has been blind-signed and is within a valid date
   range This prevents adversaries from storing many old blind-signed
   keys and rotating them quickly in order to avoid detection.

   This is achieved in the following manner:

   (1) In order to locate an accessory at time i, the OD uses SK to
   compute the hash of the desired public key Y_i.  The owner OD sends
   the unblinded, signed public key hashes to CN corresponding to the
   date range they are interested in retrieving, along with the
   corresponding info fields for each one.

   (2) CN confirms the auxiliary information on each signature is
   reasonable (e.g. falls within the last 7 days) and that the signature
   of each hash verifies correctly.

   (3) CN retrieves any report matching the hashes supplied Y_i and
   returns them to the OD, including the public key hash, the ephemeral
   public key, and encrypted payload, minus any reports where the
   timestamp does not match the correct time period from the info field
   (this would indicate that they key was being used outside of its
   intended validity period).

   (4) For each report, OD finds the public key for the report by its
   hash, and uses the corresponding private key alongside the ephemeral
   public key included in the report to decrypt the encrypted payload
   and recover the timestamp, confidence, and location data associated
   with the report.

   This design provides substantially improved privacy properties over a
   naive design:

   1.  Nobody but the owner can learn the reported location of an
       accessory because it is encrypted under Y_i.  This includes the
       central service, which just sees encrypted reports.

   2.  It is not possible to correlate the public keys broadcast across
       multiple epochs without knowing the shared key SK, which is only
       know to the owner.  However, an observer who sees multiple
       beacons within the same epoch can correlate them, as they will
       have the same Y_i.  However, fast rotation also makes it more
       difficult to detect unwanted tracking, which relies on multiple
       observations of the same identifier over time.

   However, there are a number of residual privacy threats, as described
   below.

4.8.  Reporting Device Leakage

   If the central server is able to learn the identity of the device
   reporting an accessory or the identity of the owner requesting the
   location of an accessory, then it can infer information about that
   accessory's behavior.  For instance:

   *  If device A reports accessories X and Y owned by different users
      and they both query for their devices, then the central server may
      learn that those users were in the same place, or at least their
      accessories were.

   *  If devices A and B both report tag X, then the server learns that
      A and B were in the same place.

   *  If the central server is able to learn where a reporting device is
      (e.g., by IP address) and then the user queries for that
      accessory, then the server can infer information about where the
      user was, or at least where they lost the accessory.

   These issues can be mitigated by concealing the identity and/or IP
   address of network elements communicating with the central server
   using techniques such as Oblivious HTTP [RFC9458] or MASQUE
   [RFC9298].

4.9.  Non-compliant Accessories

   The detection mechanisms described in
   [I-D.detecting-unwanted-location-trackers] depend on correct behavior
   from the tracker.  For instance, Section 3.5.1 of
   [I-D.detecting-unwanted-location-trackers] requires that accessories
   use a rotation period of 24 hours when in the "separated" state:

   When in a separated state, the accessory SHALL rotate its address
   every 24 hours.  This duration allows a platform's unwanted tracking
   algorithms to detect that the same accessory is in proximity for some
   period of time, when the owner is not in physical proximity.

   However, if an attacker were to make their own accessory that was
   generated the right beacon messages or modify an existing one, they
   could cause it to rotate the MAC address more frequently, thus
   evading detection algorithms.  The attestation mechanism described in
   Section [TODO] is intended to mitigate this attack.

5.  Security Considerations

   TODO Security - as described in [DultDoc4]?

6.  Privacy Considerations

   TODO Privacy - as described in [DultDoc4]?

7.  IANA Considerations

   This document has no IANA actions.

8.  References

8.1.  Normative References

   [I-D.detecting-unwanted-location-trackers]
              Ledvina, B., Eddinger, Z., Detwiler, B., and S. P.
              Polatkan, "Detecting Unwanted Location Trackers", Work in
              Progress, Internet-Draft, draft-detecting-unwanted-
              location-trackers-01, 20 December 2023,
              <https://datatracker.ietf.org/doc/html/draft-detecting-
              unwanted-location-trackers-01>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

8.2.  Informative References

   [BlindMy]  Travis Mayberry, Erik-Oliver Blass, and Ellis Fenske,
              "Blind My — An Improved Cryptographic Protocol to Prevent
              Stalking in Apple’s Find My Network", 2023,
              <https://petsymposium.org/popets/2023/popets-
              2023-0006.pdf>.

   [DultDoc3] Brent Ledvina, Lazarov, D., Detwiler, B., and S. P.
              Polatkan, "Detecting Unwanted Location Trackers Accessory
              Protocol", 2024, <https://www.ietf.org/archive/id/draft-
              ledvina-dult-accessory-protocol-00.html>.

   [DultDoc4] Maggie Delano and Jessie Lowell, "DRAFT Dult Threat
              Model", 2024, <https://datatracker.ietf.org/doc/html/
              draft-delano-dult-threat-model>.

   [GMCKV21]  Chinmay Garg, Aravind Machiry, Andrea Continella,
              Christopher Kruegel, and Giovanni Vigna, "Toward a secure
              crowdsourced location tracking system", 2021,
              <https://dl.acm.org/doi/10.1145/3448300.3467821>.

   [Heinrich] Alexander Heinrich, Milan Stute, Tim Kornhuber, and
              Matthias Hollick, "Who Can Find My Devices? Security and
              Privacy of Apple's Crowd-Sourced Bluetooth Location
              Tracking System", 2021,
              <https://petsymposium.org/popets/2021/popets-
              2021-0045.pdf>.

   [Okamoto]  Tatsuaki Okamoto, "Efficient blind and partially blind
              signatures without random oracles", 2006,
              <https://link.springer.com/chapter/10.1007/11681878_5>.

   [RFC9298]  Schinazi, D., "Proxying UDP in HTTP", RFC 9298,
              DOI 10.17487/RFC9298, August 2022,
              <https://www.rfc-editor.org/rfc/rfc9298>.

   [RFC9458]  Thomson, M. and C. A. Wood, "Oblivious HTTP", RFC 9458,
              DOI 10.17487/RFC9458, January 2024,
              <https://www.rfc-editor.org/rfc/rfc9458>.

   [Samsung]  Tingfeng Yu, James Henderson, Alwen Tiu, and Thomas
              Haines, "Privacy Analysis of Samsung’s Crowd-Sourced
              Bluetooth Location Tracking System", 2023,
              <https://www.usenix.org/system/files/sec23winter-prepub-
              498-yu.pdf>.

   [WhoTracks]
              Travis Mayberry, Ellis Fenske, Dane Brown, Christine
              Fossaceca, Sam Teplov, Lucas Foppe, Jeremey Martin, and
              Erik Rye, "Who Tracks the Trackers?", 2021,
              <https://dl.acm.org/doi/10.1145/3463676.3485616>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Christine Fossaceca
   Microsoft
   Email: cfossaceca@microsoft.com


   Eric Rescorla
   Windy Hill Systems, LLC
   Email: ekr@rtfm.com
